//-------------------------------------------------
// WGSL_Ya
//-------------------------------------------------





fn swap(x: u32) -> u32
{
    // swap adjacent pairs of indices
    // 0 1 2 3 4 5
    // 1 0 3 2 5 4
	//
	// IF Even Inc
	// IF Odd Dec
    return select(x - 1u, x + 1u, x % 2u == 0u);
}



fn DD_wf2( Vu_wf2: vec2f ) -> vec2f
{
    let x = Gwo_wu2.x;
    let y = Gwo_wu2.y;

    // Share texture coordinates within the workgroup
    Gwo__Vu_vwf2[x][y] = Vu_wf2;

    // Synchronise threads in workgroup
    workgroupBarrier();

    // Read texture coordinates from adjacent threads in quad
    let ddx = Gwo__Vu_vwf2[swap(x)][y] - Vu_wf2;
    let ddy = Gwo__Vu_vwf2[x][swap(y)] - Vu_wf2;

	// ARG: ch: texture_2d<f32>,
    // return textureSampleGrad(ch, trilinear_repeat, Vu_wf2, ddx, ddy);

	return vec2f( ddx.x, ddy.x );
}


const EPS = 0.000001;
const GoKwe_wfk = 0.0001;

const FAR = 64.0;
const PI = 3.1415926;

fn rotX(p: vec3f, a: f32) -> vec3f { let r = p.yz * cos(a) + vec2f(-p.z, p.y) * sin(a); return vec3f(p.x, r.x, r.y ); }
fn rotY(p: vec3f, a: f32) -> vec3f { let r = p.xz * cos(a) + vec2f(-p.z, p.x) * sin(a); return vec3f(r.x, p.y, r.y); }
fn rotZ(p: vec3f, a: f32) -> vec3f { let r = p.xy * cos(a) + vec2f(-p.y, p.x) * sin(a); return vec3f(r.x, r.y, p.z); }

fn rotM( p: vec3f, m: vec2f) -> vec3f { return rotX( rotY( p, PI * m.y ), PI * m.x ); }



// Other 3D SDF functions: https://gist.github.com/munrocket/f247155fc22ecb8edf974d905c677de1
fn sdSphere(p: vec3f, r: f32) -> f32 {
    return length(p) - r;
}

fn sdBox(p: vec3f, b: vec3f) -> f32
{
  let q = abs(p) - b;
  return length(max(q, vec3f(0.))) + min(max(q.x, max(q.y, q.z)), 0.);
}

fn opSubtract(d1: f32, d2: f32) -> f32 {
    return max(d1, -d2);
}

fn opGrid( p: vec3f, c: f32, lim: vec3f) -> vec3f {
    return p - c * clamp(round(p / c), -lim, lim);
}

fn DzKy__GeZe_wf(p0: vec3f) -> f32
{
    let p
	//= p0;
	= opGrid( p0, 6, vec3f( 3.0, 3.0, 3.0 ) );

    return min( opSubtract(sdBox(p, vec3f( 1.0, 1.0, 2.0 )), sdSphere(p, 1.37 )), sdBox( p, vec3f( 0.2 )) );

    // return opSubtract( sdSphere(p, 1.3), sdBox(p, vec3f(1)) );
	//return max( sdSphere(p, 1.3), sdBox(p, vec3f(1)) );
}

struct Dro_t
{
	Ge_wf3: vec3f
	, Vy_wu: u32
	, Ky_wu3: array<u32, 3>
	, Kwe_wu: u32
}


fn march(ro: vec3f, rd: vec3f) -> Dro_t
{
    var p: vec3f;
    var s: f32;
	var Vy_wu: u32 = 0;

	var Kwe_wu = 0u;
    for (; Kwe_wu < 2048; Kwe_wu++ )
	{
        p = ro + s * rd;
        let ds = DzKy__GeZe_wf(p);
        s += ds;

        if(ds < EPS ) { Vy_wu = 1; break; }
        if( s > FAR) { break; }

		Kwe_wu++;
    }
    return Dro_t( p, Vy_wu, array<u32, 3>( 0,0,0), Kwe_wu );
}

fn normal(p: vec3f) -> vec3f
{
    let e = vec2f(0., GoKwe_wfk );
	let Ge_wf = DzKy__GeZe_wf( p );

    return normalize(vec3f(

        Ge_wf - DzKy__GeZe_wf(p - e.yxx),
        Ge_wf - DzKy__GeZe_wf(p - e.xyx),
        Ge_wf - DzKy__GeZe_wf(p - e.xxy)
    ));
}


@compute @workgroup_size( WzGy_wuk, WzGy_wuk )
fn JiHry( @builtin( global_invocation_id ) Wz_wu3: vec3u, @builtin(local_invocation_id) WzGwo_wu3: vec3u )
{
	Gwo_wu2 = WzGwo_wu3.xy;

	let Se__Gy_wu2 = vec2u( 512, 512 );
	if( ( Wz_wu3.x >= Se__Gy_wu2.x ) || ( Wz_wu3.y >= Se__Gy_wu2.y ) ){ return; }

	let Se__Ge_wu3 = vec3u( 0, 0, 0 );
    let uv = (2.*(vec2f(Wz_wu3.xy) + .5) - vec2f( Se__Gy_wu2 )) / f32(Se__Gy_wu2.y);

	// Coordinate system: X→, Y↑, Z⊙
    var ro = vec3f( 0, 0, -15.0 );

    var rd = normalize( vec3f( uv, 2.2 ));


	let Go_wf2 = vec2f( 0.05, 0.05 );

    ro = rotM(ro, Go_wf2 );
    rd = rotM(rd, Go_wf2 );

    let Dro_l = march( ro, rd );
    let Dro__Go_wfn3 = normal( Dro_l.Ge_wf3 );

    var Po_wf3 = vec3f( 0.6 );

	if( Dro_l.Vy_wu > 0 )
	{
    	let SpeGo_wfn3 = normalize(vec3f(-1,0.3,1));
		let DroGo_wfa = clamp( 0., 1., dot( SpeGo_wfn3, Dro__Go_wfn3 ) );
	    Po_wf3 = vec3f( Dro__Go_wfn3 * 0.5 + 0.5 );
	}

   	//Po_wf3 = mix( Po_wf3, bg, vec3f( DroGo_wfa ) );
   //	Po_wf3 = smoothstep( Po_wf3, bg, vec3f( DroGo_wfa ) );
	// Po_wf3.g = select( 0, ( f32( Dro_l.Kwe_wu - 1024 ) / 1024.f ), ( Dro_l.Kwe_wu > 1024 ) );

	// SHOW STEPS TAKEN
	//let Gu_fak = clamp( 0f, 1f, f32( Dro_l.Kwe_wu ) / 512f );
	//let KuPo_wf3 = vec3( 0.4, 0.4, 0.6 );
	// EXPOSURE on RESULTS
	// Po_wf3 = mix( Po_wf3, KuPo_wf3, Gu_fak );
	// Po_wf3 = vec3f( 1. - ( Gu_fak * Gu_fak ) );
	//	Po_wf3 = vec3f( ( Gu_fak *Gu_fak * Gu_fak ) );


// HACK X & Y OFS
    textureStore( SePo_k, vec2u( Wz_wu3.x + Se__Gy_wu2.x, Se__Gy_wu2.y-1-Wz_wu3.y ), Se__Ge_wu3.z, vec4f(Po_wf3, 1.) );
}


//-------------------------------------------------
// WGSL_Yi
//-------------------------------------------------
