//==============================================
//==============================================
// WG: CMD @ SESSION UPDATE
//==============================================
//==============================================
DoWG.BriYe = async function( Sa_l, GiDri_duk  )
{
	//-------------------------------------------------
	// WORK SETUP
	//-------------------------------------------------

	//@@@
	// UPD if active
	if( !KoDz__YzYe_y() ) return;

	//@@@
	// CHECK RESIZE
	DoWG.Mz_GyHa( Sa_l );

	//@@@
	// CMD PASS BEGIN
	const KaSmz_l = Sa_l.KaSmz_l;
	const MoKro_l = KaSmz_l.createCommandEncoder( { label: 'MoKro' } );

	const TaMoVa_k =
	{
		label: 'TaMo'
	};

	//&&&
	// TIMER
	if( Sa_l.KaTy.TIMER_yk )
	{
		TaMoVa_k.timestampWrites =
		{
			querySet: Sa_l.TaGiMy_Kz_l,
			beginningOfPassWriteIndex: 0,
			endOfPassWriteIndex: 1,
		};
	}

	let TaMo_l;


/*

Media_Strms ROUND-ROBIN @ UNIFORMS
UNIFORM: buf-max = 64 KiB, RO
STORE: buf-max = 128 MiB, RW

maxDynamicUniformBuffersPerPipelineLayout: 8

min_uniform_buffer_offset_alignment: 256bu
min_storage_buffer_offset_alignment: 256bu

// Set binding group with a different uniform offset
dynamicOffset = 1 * m_uniformStride;


 // last two CPP! no JS! arguments of renderPass.setBindGroup, namely dynamicOffsetCount and dynamicOffsets array.
renderPass.setBindGroup(0, m_bindGroup, 1, &dynamicOffset);

// setBindGroup(index, bindGroup, dynamicOffsets, dynamicOffsetsStart,
             dynamicOffsetsLength)
// Entries in bindGroup with hasDynamicOffset: true set.
	bindingLayout.buffer.hasDynamicOffset = true;


MyUniforms uniforms;

// Upload first value
uniforms.time = 1.0f;
uniforms.color = { 0.0f, 1.0f, 0.4f, 1.0f };
m_queue.writeBuffer(m_uniformBuffer, 0, &uniforms, sizeof(uniforms));

// Upload second value
uniforms.time = -1.0f;
uniforms.color = { 1.0f, 1.0f, 1.0f, 0.7f };
m_queue.writeBuffer(m_uniformBuffer, m_uniformStride, &uniforms, sizeof(uniforms));

*/

	//-------------------------------------------------
	// KiCho
	//-------------------------------------------------

	//@@@
	// UPLOAD



	//@@@
	// GOLIFE
	{
		TaMo_l = MoKro_l.beginComputePass( TaMoVa_k );
		TaMo_l.pushDebugGroup('Gen GOLIFE');
		{
			TaMo_l.setPipeline( Sa_l.JiGwe02__GOLIFE );
			TaMo_l.setBindGroup(0, Sa_l.SuGweKy[  CS_Kwi_wu % 2 ]);

			const TaWz__Fo_wuk = Math.ceil(CS_Gy_k / CS_WzVu_k);
			TaMo_l.dispatchWorkgroups( TaWz__Fo_wuk, TaWz__Fo_wuk );
		}
		TaMo_l.popDebugGroup();
		TaMo_l.end();
		CS_Kwi_wu++;
	}

	//@@@
	// PTRN
	{
		TaMo_l = MoKro_l.beginComputePass( TaMoVa_k );
		TaMo_l.pushDebugGroup('Gen PTRN');
		{
			TaMo_l.setPipeline( Sa_l.PTRN_k );
			TaMo_l.setBindGroup( 0, Sa_l.SuGweKy[ 2 ] );
			TaMo_l.setBindGroup( 1, Sa_l.SuGweKy[ 3 ] );

			const WzGy__Fo_wuk = ( 512 >> 3 );
			TaMo_l.dispatchWorkgroups( WzGy__Fo_wuk, WzGy__Fo_wuk );
		}
		TaMo_l.popDebugGroup();
		TaMo_l.end();
	}

	//@@@
	// SHP
	if( 10 )
	{
		TaMo_l = MoKro_l.beginComputePass( TaMoVa_k );
		TaMo_l.pushDebugGroup('Gen SHP');
		{
			TaMo_l.setPipeline( Sa_l.SHP_k );
			TaMo_l.setBindGroup( 0, Sa_l.SuGweKy[ 2 ] );
			TaMo_l.setBindGroup( 1, Sa_l.SuGweKy[ 3 ] );

			// OFS/SIZ

			const WzGy__Fo_wuk = ( 512 >> 3 );
			TaMo_l.dispatchWorkgroups( WzGy__Fo_wuk, WzGy__Fo_wuk );
		}
		TaMo_l.popDebugGroup();
		TaMo_l.end();
	}


	//@@@
	// LGT
	if( 0 )
	{
		TaMo_l = MoKro_l.beginComputePass();
		TaMo_l.pushDebugGroup('Gen LGT');
		{
			TaMo_l.setPipeline( Sa_l.LGT_k );
			TaMo_l.setBindGroup( 0, Sa_l.SuGweKy[ 2 ] );
			TaMo_l.setBindGroup( 1, Sa_l.SuGweKy[ 3 ] );

			// OFS/SIZ

			const WzGy__Fo_wuk = ( 512 >> 3 );
			TaMo_l.dispatchWorkgroups( WzGy__Fo_wuk, WzGy__Fo_wuk );
		}
		TaMo_l.popDebugGroup();
		TaMo_l.end();
	}

	//@@@
	// MAKE
	// TaMo_l = MoKro_l.beginComputePass();
	// TaMo_l.pushDebugGroup('Gen MEXEL');
	// {
	// 	TaMo_l.setPipeline( Sa_l.MEXEL_Mz_k );
	// 	TaMo_l.setBindGroup( 0, Sa_l.SuGweKy[ 4 ] );
	// 	const WzGy__Fo_wuk = ( 512 >> 3 );
	// 	TaMo_l.dispatchWorkgroups( WzGy__Fo_wuk, WzGy__Fo_wuk );
	// }
	// TaMo_l.popDebugGroup();
	// TaMo_l.end();




	//@@@
	// ADAPT


	//-------------------------------------------------
	// FORMAT-&-COMPRESS RESULTS
	//-------------------------------------------------
	if( 10 )
	{
		MoKro_l.copyTextureToTexture
		(
			// src:
			{ texture: Sa_l.Wz__TaGwa_l, mipLevel: 0, origin: [0, 0, 0] }
			// dst:
			, { texture: Sa_l.Spy__TaGwa_l, mipLevel: 0, origin: [0, 0, 0 ] }
			// size:
			, { width: 1024, height: 512 }
		);

		MoKro_l.copyTextureToTexture
		(
			// src:
			{ texture: Sa_l.Wz__TaGwa_l, mipLevel: 0, origin: [0, 0, 0] }
			// dst:
			, { texture: Sa_l.Spy__TaGwa_l, mipLevel: 1, origin: [0, 0, 0 ] }
			// size:
			, { width: 512, height: 256 }
		);

		MoKro_l.copyTextureToTexture
		(
			// src:
			{ texture: Sa_l.Wz__TaGwa_l, mipLevel: 0, origin: [0, 0, 0] }
			// dst:
			, { texture: Sa_l.Spy__TaGwa_l, mipLevel: 2, origin: [0, 0, 0 ] }
			// size:
			, { width: 256, height: 128 }
		);
	}

	//-------------------------------------------------
	// DISP_PRESENT
	//-------------------------------------------------

	//@@@
	// DISPLAY CANVAS FETCH
	TaMo_l = MoKro_l.beginComputePass();
	{
		let MxPo_JaPo_l = Sa_l.MxPo_Sx_l.getCurrentTexture();
		let MxPo__bindGroup = KaSmz_l.createBindGroup
		({
			layout: Sa_l.MxPoCho_qk.getBindGroupLayout(1),
			entries: [ { binding: 0, resource: MxPo_JaPo_l } ],
		});

		{
			TaMo_l.setPipeline( Sa_l.MxPoCho_qk );
			TaMo_l.setBindGroup( 0, Sa_l.SuGweKy[ 2 ] );
			TaMo_l.setBindGroup( 1, MxPo__bindGroup );

			TaMo_l.dispatchWorkgroups( ( MxPo_JaPo_l.width + 7 ) >> 3, ( MxPo_JaPo_l.height + 7 ) >> 3 );
		}
		// Suggest Release Dynamic Objects
		MxPo_JaPo_l = null;
		MxPo__bindGroup = null;
	}
	TaMo_l.end();


	//-------------------------------------------------
	// DNLOAD^TxCho
	//-------------------------------------------------

	//@@@
	// QUERIES
	// WzMe^TIMER RESULTS
	if( Sa_l.KaTy.TIMER_yk )
	{
		MoKro_l.resolveQuerySet
		(
			Sa_l.TaGiMy_Kz_l,
			0, // index of first query to resolve
			TaGiMy__Fo_wuk, // number of queries to resolve
			Sa_l.TaGiMy_Ma_l, 0 // destination offset
		);

		// COPY QUERY RESULTS
		if( Sa_l.ToMy_Sma_l.mapState === 'unmapped' )
		{
			MoKro_l.copyBufferToBuffer( Sa_l.TaGiMy_Ma_l, 0, Sa_l.ToMy_Sma_l, 0, Sa_l.ToMy_Sma_l.size);
		};
	}

	KaSmz_l.queue.submit( [ MoKro_l.finish() ] );
	// NOTE: there is a Promise @ onSubmittedWorkDone
	// stalls
	// await KaSmz_l.queue.onSubmittedWorkDone();


	//@@@
	// TIMER
	// timestamps are recorded in nanoseconds.
    if( Sa_l.KaTy.TIMER_yk && Sa_l.ToMy_Sma_l.mapState === 'unmapped' )
	{
		//SmaSme( "[WG] TIMER WAIT" );
      	await Sa_l.ToMy_Sma_l.mapAsync( GPUMapMode.READ ).then(() =>
		{
			//SmaSme( "[WG] TIMER READ" );
        	const times = new BigUint64Array( Sa_l.ToMy_Sma_l.getMappedRange()	);
        	const KaBxGiHa_df = ( Number(times[1] - times[0]) ) / 1000000.0;
			Ko.KaBxGiHa_df = Ko.KaBxGiHa_df * 0.9 + KaBxGiHa_df * 0.1;
        	Sa_l.ToMy_Sma_l.unmap();
      });
    }


	//@@@
	// DNLOAD SCRNSHOT
	if( ( Sa_l.TxCho__KriJaKu_v.length > 0 ) && ( Sa_l.TxCho__TraJaKu_v.length === 0 ) )
	{
		//&&&
		// XFER Req to Use
		Sa_l.TxCho__TraJaKu_v = Sa_l.TxCho__KriJaKu_v;
		Sa_l.TxCho__KriJaKu_v = [];

		// FILL TxCho__JxRe_l
		// then READ
		let MyFo_wu = 0;
		const MoKro_l = KaSmz_l.createCommandEncoder();

		Sa_l.TxCho__TraJaKu_v.forEach
		( function( Ku_l, Vx_wu )
		{
			const ChoFo_wuk = ( 4 * Ku_l.GyGx_wu * Ku_l.GyGa_wu );

			SmaSme( "[WG] SCRNSHOT[", Vx_wu, "] Lv"
				, Ku_l.Brz_wu, " = ", Ku_l.GeGx_wu, Ku_l.GeGa_wu, Ku_l.GeGz_wu, "@",  Ku_l.GyGx_wu, Ku_l.GyGa_wu  );

			MoKro_l.copyTextureToBuffer
			(
				{ texture: Sa_l.Spy__TaGwa_l, mipLevel: Ku_l.Brz_wu, origin: [ Ku_l.GeGx_wu, Ku_l.GeGa_wu, Ku_l.GeGz_wu ] }
				// bytesPerRow MULTIPLE of 256, so 4bpp => MULTIPLE of 64
				, { buffer: Sa_l.TxCho__JxRe_l, offset: MyFo_wu, bytesPerRow: 4 * Ku_l.GyGx_wu, rowsPerImage: Ku_l.GyGa_wu }
				, { width: Ku_l.GyGx_wu, height: Ku_l.GyGa_wu, depthOrArrayLayers: 1 }
			);

			MyFo_wu += ChoFo_wuk;
		}); // for ALL READS

		KaSmz_l.queue.submit([MoKro_l.finish()]);

		const GeZo_wuk = 0;
		await Sa_l.TxCho__JxRe_l.mapAsync( GPUMapMode.READ, GeZo_wuk, MyFo_wu );
		if( Sa_l.TxCho__JxRe_l.mapState === "mapped" )
		{
			// SAVE BUF to FILE
			const MyTo_v = Sa_l.TxCho__JxRe_l.getMappedRange( GeZo_wuk, MyFo_wu );

			// ITER SECTIONS
			const Ku_l = Sa_l.TxCho__TraJaKu_v[ 0 ];
			{
				// SAVE for 'continuous Blit in WebXR'
				const WzPo_l = new OffscreenCanvas( Ku_l.GyGx_wu, Ku_l.GyGa_wu );
				if( MyTo_v && WzPo_l )
				{
					SmaSme( "[WG] TxCho__Fo", MyTo_v.byteLength );

					let PoTi_v = new Uint8ClampedArray( MyTo_v );
					let IDAT_l = new ImageData( PoTi_v, Ku_l.GyGx_wu, Ku_l.GyGa_wu );

					const SxHry_l = WzPo_l.getContext("2d");
					if( SxHry_l )
					{
						SxHry_l.putImageData( IDAT_l, 0, 0 );
						// INVERT Y for IMAGE SCREENSHOT;
						SxHry_l.transform(1, 0, 0, -1, 0, Ku_l.GyGa_wu );
						SxHry_l.globalCompositeOperation = "copy"; // if you have transparent pixels
						SxHry_l.drawImage( SxHry_l.canvas,0,0);

						// SAFARI: NO webp!
						// image/webp,jpeg,png
						const blobA = await WzPo_l.convertToBlob( { type: 'image/jpeg', quality: 0.67 } );
						Hra6_Ku__ToKz_ChyBLOB( blobA, 'SHOT_A.jpeg');

						// const blobB = await WzPo_l.convertToBlob( { type: 'image/jpeg', quality: 0.33 } );
						// Hra6_Ku__ToKz_ChyBLOB( blobB, 'SHOT_B.jpeg');

						// const blobC = await WzPo_l.convertToBlob( { type: 'image/jpeg', quality: 0.00 } );
						// Hra6_Ku__ToKz_ChyBLOB( blobC, 'SHOT_C.jpeg');

					}// if ctx

					IDAT_l = null;
					PoTi_v = null;
				}// if canvas
			}// per Request

			// SIGNAL we're clear
			Sa_l.TxCho__JxRe_l.unmap();
			Sa_l.TxCho__TraJaKu_v = [];
		}// per IMG

	}// if DNLOAD


}

//==============================================
//==============================================
// WG: CMD @ SESSION UPDATE
//==============================================
//==============================================
