//==============================================
//==============================================
// WG: CLONE
//==============================================
//==============================================

//==============================================
// CLONE PROG
//==============================================
DoWG.KiCho_JiJa = async function( Sa_l )
{
	if( DoWG__KrzYeHo_y( Sa_l )){ return; }
	SmaSme( "[WG] DoWG JiJa: CLONE PROG" );


	// SAVE SHADER PRECOMPILED
	// // Check for shader cache support
	// if (KaSmz_l.features.has('pipeline-cache')) {
		//   // Get cached shader binary if available
		//   const cachedShader = await caches.match('/shaders/particle.wgsl.bin');

		//   if (cachedShader) {
//     // Use pre-compiled binary shader
//     const binaryData = await cachedShader.arrayBuffer();
//     const pipeline = KaSmz_l.createRenderPipelineWithBinary(binaryData);
//   } else {
	//     // Compile and cache for future use
	//     const shader = KaSmz_l.createShaderModule({
//       code: particleShaderCode
//     });

//     const pipeline = KaSmz_l.createRenderPipeline({
	//       vertex: { module: shader, entryPoint: 'vertexMain' },
	//       fragment: { module: shader, entryPoint: 'fragmentMain' },
	//       // Other pipeline settings...
	//     });

	//     // Cache the compiled binary
	//     const binary = await pipeline.getBinary();
	//     await caches.put('/shaders/particle.wgsl.bin', new Response(binary));
	//   }
	// }

}

//==============================================
// CLONE CRAFT
//==============================================
DoWG.KiCho_SuTy = function( Sa_l )
{
	if( DoWG__KrzYeHo_y( Sa_l )){ return; }
	SmaSme( "[WG] DoWG JiJa: CLONE CRAFT" );


}

//==============================================
// CLONE SEQ
//==============================================
DoWG.KiCho_JxRe = function( Sa_l )
{
	if( DoWG__KrzYeHo_y( Sa_l )){ return; }
	SmaSme( "[WG] KiCho_JxRe: CLONE SEQUENCE" );

	function createBuffer( KaSmz_l, data, usage )
	{
		const buffer = Sa_l.KaSmz_l.createBuffer
		({
			size: data.byteLength,
			usage,
			mappedAtCreation: true,
		});

		const dst = new data.constructor( buffer.getMappedRange() );
		dst.set( data );
		buffer.unmap();
		return buffer;
	}
	// const positions = new Float32Array( [ 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1 ] );

	// Sa_l.positionBuffer = createBuffer( KaSmz_l, positions, GPUBufferUsage.STORAGE );

	//@@@
	// // Create a buffer with direct memory mapping
	//   const buffer = KaSmz_l.createBuffer({
	// 	  size: 1024 * 1024 * 16, // 16MB
	// 	  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
	// 	  mappedAtCreation: true,
	// 	  memoryControlFlags: ['persist', 'direct'] // WebGPU 2.0 feature
	// 	});

	// 	// Get direct access to GPU memory
	// 	const arrayBuffer = buffer.getMappedRange();
	// 	const view = new Float32Array(arrayBuffer);

	// 	// Write directly to GPU memory
	// 	for (let i = 0; i < 1000000; i++) {
	// 		view[i] = Math.sin(i * 0.01);
	// 	}

	// 	// Submit without copying
	// 	buffer.unmap({ commit: true, preserve: true });
	// }

}

//==============================================
// CLONE SIGNAL via SAMPLE ARRAY
//
// Row = Block Row!
// raw textures: block width/height = 1
// compressed textures, ex: bc1-rgba-unorm, block width/height = 4
//==============================================
DoWG.KiCho_JaTi = function( Sa_l, GeGx_wuk, GeGa_wuk, GeGz_wuk, GyGx_wuk, GyGa_wuk, JaTi_vk )
{
	if( DoWG__KrzYeHo_y( Sa_l )){ return; }

	//@@@
	// UPLOAD TEXTURE?
	Sa_l.KaSmz_l.queue.writeTexture
	(
		{
			texture: Sa_l.Spy__TaGwa_l
			, mipLevel: 0
			, origin: [ GeGx_wuk, GeGa_wuk, GeGz_wuk ]
		}
		, JaTi_vk
		,
		{
			// RGBA8: 4bu/Ti
			// BCN:
			// AST:
			bytesPerRow: GyGx_wuk * 4,
			rowsPerImage: GyGa_wuk
		}
		,
		{
			width: GyGx_wuk,
			height: GyGa_wuk,
			depthOrArrayLayers: 1,
		}
	);
}


//==============================================
// CLONE SIGNAL OBJECT via HTML_DOM
//  HTMLCanvasElement, HTMLImageElement, HTMLVideoElement
// ImageBitmap, ImageData, OffscreenCanvas, or VideoFrame
//==============================================
DoWG.KiCho_JaKz = function( Sa_l, GeGx_wuk, GeGa_wuk, GeGz_wuk, GyGx_wuk, GyGa_wuk, JaKz_vk )
{
	if( DoWG__KrzYeHo_y( Sa_l )){ return; }

	//@@@
	// UPLOAD TEXTURE?
	Sa_l.KaSmz_l.queue.copyExternalImageToTexture
	(
		// source
		{
			source: JaKz_vk
			, origin: [ 0, 0 ]
			, flipY: true
		}
		, // destination
		{
			texture: Sa_l.Spy__TaGwa_l
			, mipLevel: 0
			, origin: [ GeGx_wuk, GeGa_wuk, GeGz_wuk ]
			, premultipliedAlpha: false
			// "srgb" and "display-p3"
			, colorSpace: "srgb"
		}
		, //copySize
		{
			width: GyGx_wuk,
			height: GyGa_wuk,
			depthOrArrayLayers: 1,
		}
	);
}


//==============================================
//==============================================
// WG: CLONE
//==============================================
//==============================================
