//==============================================
// SYSLIFE
//==============================================

//==============================================
// JSON_RD^ToKz_My
//==============================================
async function Hra6_Ku__ToKz_My__vJSON( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	SmaJe( "[USR_STOR] FILE seeking JSON: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg, { headers: { Accept: 'application/json' } } );
		const ToKz_v = await Smx_k.json();
		//SmaJe( "[USR_STOR]", ToKz_v );
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoSy__KeDru_l.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};

//==============================================
// TXT_RD^ToKz_My
//==============================================
async function Hra6_Ku__ToKz_My__vsg( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	//SmaJe( "[USR_STOR] FILE seeking TEXT: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg );
		const ToKz_v = await Smx_k.text();
		// SmaJe( "[USR_STOR]", ToKz_v );
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoSy__KeDru_l.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};

//==============================================
// BLOB_RD^ToKz_My
//==============================================
async function Hra6_Ku__ToKz_My__vBLOB( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	SmaJe( "[USR_STOR] FILE seeking BLOB: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg );
		const ToKz_v = await Smx_k.blob();
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoSy__KeDru_l.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};

//==============================================
// BLOB_WRT^ToKz_Chy
//==============================================
async function Hra6_Ku__ToKz_ChyBLOB(blob, filename)
{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
}

//==============================================
// BUF_RD^ToKz_My
//==============================================
async function Hra6_Ku__ToKz_My__vBUF( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	SmaJe( "[USR_STOR] FILE seeking BUFFER: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg );
		const ToKz_v = await Smx_k.arrayBuffer();
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoSy__KeDru_l.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};


//==============================================
// IDB STOR
//==============================================

//---------------------------------------------------
// IDB INIT
//---------------------------------------------------
const IDB_Ko_l = new Promise((resolve, reject) =>
{
	// IDB NAME & VER #
	const Da_wuk = 1;
	const request = indexedDB.open('handle', Da_wuk );

	// CALLED when we change VER# above
	request.onupgradeneeded = ( e ) =>
	{
		const db = event.target.result;
		db.createObjectStore( 'handles', { keyPath: 'id' } );
	};

	request.onsuccess = ( e ) =>
	{
		// SmaJe( "[USR_STOR] IDB_Good\n");
		resolve( e.target.result );
	};

	request.onerror = ( e ) =>
	{
		SmaTrx( e );
		reject( e.target.error);
	};
});


//---------------------------------------------------
// IDB Chy
//---------------------------------------------------
/* Saves a directory handle to the database.
 * @param {FileSystemDirectoryHandle} ToKzVy  - The directory handle to save.
 * @returns {Promise<void>} A promise that resolves when the handle is saved.
 */
//async function
const IDB_ToKzVy__Chy = (Va, ToKzVy) =>
{
	return new Promise((resolve, reject) =>
	{
		IDB_Ko_l.then((db) =>
		{
			const transaction = db.transaction(['handles'], 'readwrite');
			const store = transaction.objectStore( 'handles' );
			const request = store.put({id: Va, handle: ToKzVy});

			request.onsuccess = () =>
			{
				SmaJe( "[USR_STOR] IDB Handle Saved\n");
				resolve();
			}
			request.onerror = () =>
			{
				SmaJe( "[USR_STOR] IDB Handle Failed\n");
				reject( request.error );
			}
		});
	});
};

//---------------------------------------------------
// IDB My
//---------------------------------------------------
// Retrieves the last saved folder handle from the database.
// @returns {Promise<FileSystemDirectoryHandle|undefined>}
// A promise that resolves with the folder handle or undefined if not found.
//
const IDB_ToKzVy__My = ( Va ) =>
{
	return new Promise((resolve, reject) =>
	{
		IDB_Ko_l.then((db) =>
		{
			const transaction = db.transaction(['handles'], 'readonly');
			const store = transaction.objectStore('handles');
			const request = store.get(Va);

			request.onsuccess = ( e ) =>
			{
				SmaJe( "[USR_STOR] IDB Handle Found\n" + e.target.result );
				resolve( e.target.result?.handle );
			}

			request.onerror = () =>
			{
				SmaJe( "[USR_STOR] IDB Handle UNK\n");
				reject(request.error);
			}
		});
	});
};


//==============================================
// END
//==============================================
