//==============================================
// SYSLIFE
//==============================================

//==============================================
// JSON_ADD^Cha
//==============================================
async function Hrz7_Kru__ToKz_vJSON( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	SmaSme( "FILE seeking JSON: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg, { headers: { Accept: 'application/json' } } );
		const ToKz_v = await Smx_k.json();
		//SmaSme( ToKz_v );
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoKeDru.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};

//==============================================
// TXT_ADD^Cha
//==============================================
async function Hrz7_Kru__ToKz_vsg( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	//SmaSme( "FILE seeking TEXT: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg );
		const ToKz_v = await Smx_k.text();
		// SmaSme( ToKz_v );
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoKeDru.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};

//==============================================
// BLOB_ADD^Cha
//==============================================
async function Hrz7_Kru__ToKz_vBLOB( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	SmaSme( "FILE seeking BLOB: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg );
		const ToKz_v = await Smx_k.blob();
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoKeDru.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};

//==============================================
// BUF_ADD^Cha
//==============================================
async function Hrz7_Kru__ToKz_vBUF( ChaKuTu_vsg, ToKzVa_vsg )
{
	let KuTu_vbg = BriDz__Mx_KuTu_vsg + ChaKuTu_vsg + ToKzVa_vsg;
	SmaSme( "FILE seeking BUFFER: " + KuTu_vbg );
	try
	{
		const Smx_k = await fetch( KuTu_vbg );
		const ToKz_v = await Smx_k.arrayBuffer();
		return ToKz_v;
	}
	catch ( e ) { MoDzTrx( KoKeDru.TrxJy__SuKz_GriHo_vsg + " @ " + ToKzVa_vsg + " --> " + e ); }
	return null;
};


//==============================================
// IDB STOR
//==============================================

//---------------------------------------------------
// IDB
//---------------------------------------------------
const IDB_Ko_l = new Promise((resolve, reject) =>
{
	// IDB NAME
	const request = indexedDB.open('handle', 1);

	request.onupgradeneeded = (event) =>
	{
		const db = event.target.result;
		db.createObjectStore('handles', {keyPath: 'id'});
	};

	request.onsuccess = (event) =>
		{
		SmaSme("IDB_Good\n");
		resolve(event.target.result);
	};

	request.onerror = (event) => {
		console.error(event);
		reject(event.target.error);
	};
});


//---------------------------------------------------
// Chy
//---------------------------------------------------
/* Saves a directory handle to the database.
 * @param {FileSystemDirectoryHandle} ToKzVy  - The directory handle to save.
 * @returns {Promise<void>} A promise that resolves when the handle is saved.
 */
//async function
const IDB_ToKzVy__Chy = (Va, ToKzVy) =>
{
	return new Promise((resolve, reject) => {
		IDB_Ko_l.then((db) => {
			const transaction = db.transaction(['handles'], 'readwrite');
			const store = transaction.objectStore('handles');
			const request = store.put({id: Va, handle: ToKzVy});

			request.onsuccess = () => {
				SmaSme("IDB Handle Saved\n");
				resolve();
			}
			request.onerror = () => {
				SmaSme("IDB Handle Failed\n");
				reject(request.error);
			}
		});
	});
};

//---------------------------------------------------
// My
//---------------------------------------------------
/**
 * Retrieves the last saved folder handle from the database.
 * @returns {Promise<FileSystemDirectoryHandle|undefined>} A promise that resolves with the folder handle or undefined if not found.
 */
const IDB_ToKzVy__My = (Va) =>
{
	return new Promise((resolve, reject) =>
	{
		IDB_Ko_l.then((db) =>
		{
			const transaction = db.transaction(['handles'], 'readonly');
			const store = transaction.objectStore('handles');
			const request = store.get(Va);

			request.onsuccess = (event) =>
			{
				SmaSme("IDB Handle Found\n" + event.target.result);
				resolve(event.target.result?.handle);
			}

			request.onerror = () =>
			{
				SmaSme("IDB Handle UNK\n");
				reject(request.error);
			}
		});
	});
};


//==============================================
// END
//==============================================
