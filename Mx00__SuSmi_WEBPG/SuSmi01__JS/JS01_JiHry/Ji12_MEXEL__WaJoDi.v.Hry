//-------------------------------------------------
// WGSL_Ya
//-------------------------------------------------

//------------------------------------------
// STRUCT
//------------------------------------------

struct Dro_t
{
	Ge_wf3: vec3f
	, Vy_wu: u32
	, Ky_wu2: array<u32, 2>
	, GeZe_wf: f32
	, Kwe_wu: u32
}


//------------------------------------------
// NRM_STEP
// !!! Shld be distance/object scaled !!!
const GoKwe_wfk = 0.01;

// SMALLEST STEP
const KwiBraHi_wuk = 128;
const KwiGyHu_wfk = 0.01;

const GeZeHi_wfk = 64.0;

const PI = 3.1415926;

//------------------------------------------
// XFRM
//------------------------------------------
fn rotX(p: vec3f, a: f32) -> vec3f { let r = p.yz * cos(a) + vec2f(-p.z, p.y) * sin(a); return vec3f(p.x, r.x, r.y ); }
fn rotY(p: vec3f, a: f32) -> vec3f { let r = p.xz * cos(a) + vec2f(-p.z, p.x) * sin(a); return vec3f(r.x, p.y, r.y); }
fn rotZ(p: vec3f, a: f32) -> vec3f { let r = p.xy * cos(a) + vec2f(-p.y, p.x) * sin(a); return vec3f(r.x, r.y, p.z); }

fn rotM( p: vec3f, m: vec2f) -> vec3f { return rotX( rotY( p, PI * m.y ), PI * m.x ); }


//------------------------------------------
// WRK
//------------------------------------------
fn swap(x: u32) -> u32
{
    // swap adjacent pairs of indices
    // 0 1 2 3 4 5
    // 1 0 3 2 5 4
	//
	// IF Even Inc
	// IF Odd Dec
    return select(x - 1u, x + 1u, x % 2u == 0u);
}

//------------------------------------------
// DERIVATIVE
//------------------------------------------

fn DD_wf2( Vu_wf2: vec2f ) -> vec2f
{
    let x = Gwo_wu2.x;
    let y = Gwo_wu2.y;

    // Share texture coordinates within the workgroup
    Gwo__Vu_vwf2[x][y] = Vu_wf2;

    // Synchronise threads in workgroup
    workgroupBarrier();

    // Read texture coordinates from adjacent threads in quad
    let ddx = Gwo__Vu_vwf2[swap(x)][y] - Vu_wf2;
    let ddy = Gwo__Vu_vwf2[x][swap(y)] - Vu_wf2;

	// ARG: ch: texture_2d<f32>,
    // return textureSampleGrad(ch, trilinear_repeat, Vu_wf2, ddx, ddy);

	return vec2f( ddx.x, ddy.x );
}


//------------------------------------------
// SHP
//------------------------------------------

// Other 3D SDF functions: https://gist.github.com/munrocket/f247155fc22ecb8edf974d905c677de1
fn sdSphere(p: vec3f, r: f32) -> f32 {
    return length(p) - r;
}

fn sdBox(p: vec3f, b: vec3f) -> f32
{
  let q = abs(p) - b;
  return length(max(q, vec3f(0.))) + min(max(q.x, max(q.y, q.z)), 0.);
}

fn opSubtract(d1: f32, d2: f32) -> f32 {
    return max(d1, -d2);
}

fn opGrid( p: vec3f, c: f32, lim: vec3f) -> vec3f {
    return p - c * clamp(round(p / c), -lim, lim);
}


//------------------------------------------
// MODEL
//------------------------------------------
fn DzKy__GeZe_wf(p0: vec3f) -> f32
{
    let p
	//= p0;
	= opGrid( p0, 8, vec3f( 1.0, 1.0, 6.0 ) );

    //return min( opSubtract(sdBox(p, vec3f( 1.5, 1.0, 2.0 )), sdSphere(p, 1.37 )), sdBox( p, vec3f( 0.2 )) );
    return opSubtract( sdSphere(p, 2.67 ), sdBox(p, vec3f(2) ) );
	//return max( sdSphere(p, 1.3), sdBox(p, vec3f(1)) );
}

//------------------------------------------
// GEOM
//------------------------------------------
fn normal(p: vec3f) -> vec3f
{
    let e = vec2f(0., GoKwe_wfk );
	let Ge_wf = DzKy__GeZe_wf( p );

    return normalize(vec3f(

        Ge_wf - DzKy__GeZe_wf(p - e.yxx),
        Ge_wf - DzKy__GeZe_wf(p - e.xyx),
        Ge_wf - DzKy__GeZe_wf(p - e.xxy)
    ));
}


//------------------------------------------
// SCENE
//------------------------------------------
fn march(ro: vec3f, rd: vec3f) -> Dro_t
{
    var p: vec3f;
    var s: f32;
	var Vy_wu: u32 = 0;

	var Kwe_wu = 0u;
    for (; Kwe_wu <= KwiBraHi_wuk; Kwe_wu++ )
	{
        p = ro + s * rd;

		let ds = DzKy__GeZe_wf(p);
        if( ds < KwiGyHu_wfk ) { Vy_wu = 1; break; }

        s += ds;
        if( s > GeZeHi_wfk) { break; }

		Kwe_wu++;
    }

    return Dro_t( p, Vy_wu, array<u32, 2>( 0,0 ), s, Kwe_wu );
}

//------------------------------------------
// OBSERVE
//------------------------------------------
@compute @workgroup_size( WzGy_wuk, WzGy_wuk )
fn JiHry( @builtin( global_invocation_id ) Wz_wu3: vec3u, @builtin(local_invocation_id) WzGwo_wu3: vec3u )
{
	Gwo_wu2 = WzGwo_wu3.xy;

	let Se__Gy_wu2 = vec2u( 512, 512 );
	if( ( Wz_wu3.x >= Se__Gy_wu2.x ) || ( Wz_wu3.y >= Se__Gy_wu2.y ) ){ return; }

	let Se__Ge_wu3 = vec3u( 0, 0, 0 );
    let uv = (2.*(vec2f(Wz_wu3.xy) + .5) - vec2f( Se__Gy_wu2 )) / f32(Se__Gy_wu2.y);

	// Coordinate system: X→, Y↑, Z⊙
    var ro = vec3f( 0.50, 0.50, -64.0 );

    var rd = normalize( vec3f( uv, 2.2 ));

	let Go_wf2 = vec2f( 0.01, 0.0 );

    ro = rotM(ro, Go_wf2 );
    rd = rotM(rd, Go_wf2 );

    let Dro_l = march( ro, rd );
    let Dro__Go_wfn3 = normal( Dro_l.Ge_wf3 );

    var Po_wf3 = vec3f( 0.4, 0.4, 1. );

	// if( Dro_l.Vy_wu > 0 ) CONTACT ID
	if( Dro_l.GeZe_wf < GeZeHi_wfk )
	{

		//Po_wf3 = mix( Po_wf3, bg, vec3f( DroGo_wfa ) );
	//	Po_wf3 = smoothstep( Po_wf3, bg, vec3f( DroGo_wfa ) );
		// Po_wf3.g = select( 0, ( f32( Dro_l.Kwe_wu - 1024 ) / 1024.f ), ( Dro_l.Kwe_wu > 1024 ) );

		// SHOW STEPS TAKEN & EXPOSE RESULTS
		if( Wz_wu3.x >= 256u )
		{
			var Gu_fak = clamp( 0f, 1f, f32( Dro_l.Kwe_wu ) / f32( KwiBraHi_wuk >> 1 )  );
			Gu_fak = smoothstep( 0.f, 1.f, Gu_fak *Gu_fak );
			Po_wf3 = select( vec3f( 1. - Gu_fak ), vec3f( Gu_fak ), Wz_wu3.y >= 256u );
		}
		else if ( Wz_wu3.y >= 256u )
		{
			Po_wf3 = vec3( Dro_l.GeZe_wf / GeZeHi_wfk );
		}
		else
		{
			let SpeGo_wfn3 = normalize(vec3f(-1, 0.3,1));
			let DroGo_wfa = clamp( 0., 1., dot( SpeGo_wfn3, Dro__Go_wfn3 ) );
			Po_wf3 = vec3f( Dro__Go_wfn3 * 0.5 + 0.5 );
		}
	}

	// HACK X & Y OFS
    textureStore( SePo_k, vec2u( Wz_wu3.x + Se__Gy_wu2.x, Se__Gy_wu2.y-1-Wz_wu3.y ), Se__Ge_wu3.z, vec4f(Po_wf3, 1.) );
}


//-------------------------------------------------
// WGSL_Yi
//-------------------------------------------------
